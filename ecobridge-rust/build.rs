use std::env;
use std::path::PathBuf;

fn main() {
    // 获取当前项目的根目录
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    
    // 设定生成的 C 头文件路径
    let output_file = PathBuf::from(&crate_dir).join("ecobridge_rust.h");

    // ==================== 1. cbindgen 配置 ====================
    
    let mut config = cbindgen::Config::default();
    
    config.language = cbindgen::Language::C;
    
    // [关键修复] 设置生成的风格为 Type (typedef struct Name { ... } Name;)
    // 这样 jextract 生成的 Java 类名就是 "MarketConfig" 而不是内部结构体名称
    config.style = cbindgen::Style::Type;

    config.header = Some(String::from(
        "/* Auto-generated by cbindgen - DO NOT EDIT MANUALLY */\n\
         /* EcoBridge Economy System - High-Performance Rust Engine */\n\
         /* For use with Java 25 Project Panama (Foreign Function API) */"
    ));
    
    config.include_guard = Some(String::from("ECOBRIDGE_RUST_H"));
    
    config.sys_includes = vec![
        String::from("stdint.h"),
        String::from("stdbool.h"),
    ];
    
    config.no_includes = true;
    
    // 解析配置
    config.parse.parse_deps = false; // 建议设为 true 以解析依赖中的类型
    config.parse.clean = true;
    
    // [关键修复] 导出配置：务必设置为 None，不要加前缀！
    // 之前设置为 "ecobridge_" 导致 Java 端生成了 ecobridge_MarketConfig
    config.export.prefix = None; 
    
    // 结构体配置
    config.structure.rename_fields = cbindgen::RenameRule::None;
    
    // 枚举配置
    config.enumeration.rename_variants = cbindgen::RenameRule::ScreamingSnakeCase;
    
    // 文档配置
    config.documentation = true;
    config.documentation_style = cbindgen::DocumentationStyle::C;

    // ==================== 2. 执行生成器 ====================

    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(config)
        .generate()
        .expect("Critical Error: Unable to generate C bindings via cbindgen")
        .write_to_file(&output_file);

    // ==================== 3. 编译触发机制 ====================

    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=build.rs");

    // ==================== 4. 跨平台链接器配置 ====================
    
    configure_platform_linker();
}

fn configure_platform_linker() {
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();

    match target_os.as_str() {
        "windows" => {
            // [Fix] DuckDB 依赖在 Windows 上需要链接 Restart Manager API
            println!("cargo:rustc-link-lib=Rstrtmgr");
        }
        "macos" => {
            println!("cargo:rustc-link-arg=-Wl,-install_name,@rpath/libecobridge_rust.dylib");
        }
        "linux" => {
            println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
        }
        _ => {}
    }
}